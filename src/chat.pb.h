// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chat.proto

#ifndef PROTOBUF_INCLUDED_chat_2eproto
#define PROTOBUF_INCLUDED_chat_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_chat_2eproto 

namespace protobuf_chat_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_chat_2eproto
namespace chat {
class ChangeStatus;
class ChangeStatusDefaultTypeInternal;
extern ChangeStatusDefaultTypeInternal _ChangeStatus_default_instance_;
class ClientPetition;
class ClientPetitionDefaultTypeInternal;
extern ClientPetitionDefaultTypeInternal _ClientPetition_default_instance_;
class ConnectedUsersResponse;
class ConnectedUsersResponseDefaultTypeInternal;
extern ConnectedUsersResponseDefaultTypeInternal _ConnectedUsersResponse_default_instance_;
class MessageCommunication;
class MessageCommunicationDefaultTypeInternal;
extern MessageCommunicationDefaultTypeInternal _MessageCommunication_default_instance_;
class ServerResponse;
class ServerResponseDefaultTypeInternal;
extern ServerResponseDefaultTypeInternal _ServerResponse_default_instance_;
class UserInfo;
class UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
class UserRegistration;
class UserRegistrationDefaultTypeInternal;
extern UserRegistrationDefaultTypeInternal _UserRegistration_default_instance_;
class UserRequest;
class UserRequestDefaultTypeInternal;
extern UserRequestDefaultTypeInternal _UserRequest_default_instance_;
}  // namespace chat
namespace google {
namespace protobuf {
template<> ::chat::ChangeStatus* Arena::CreateMaybeMessage<::chat::ChangeStatus>(Arena*);
template<> ::chat::ClientPetition* Arena::CreateMaybeMessage<::chat::ClientPetition>(Arena*);
template<> ::chat::ConnectedUsersResponse* Arena::CreateMaybeMessage<::chat::ConnectedUsersResponse>(Arena*);
template<> ::chat::MessageCommunication* Arena::CreateMaybeMessage<::chat::MessageCommunication>(Arena*);
template<> ::chat::ServerResponse* Arena::CreateMaybeMessage<::chat::ServerResponse>(Arena*);
template<> ::chat::UserInfo* Arena::CreateMaybeMessage<::chat::UserInfo>(Arena*);
template<> ::chat::UserRegistration* Arena::CreateMaybeMessage<::chat::UserRegistration>(Arena*);
template<> ::chat::UserRequest* Arena::CreateMaybeMessage<::chat::UserRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace chat {

// ===================================================================

class UserRegistration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.UserRegistration) */ {
 public:
  UserRegistration();
  virtual ~UserRegistration();

  UserRegistration(const UserRegistration& from);

  inline UserRegistration& operator=(const UserRegistration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRegistration(UserRegistration&& from) noexcept
    : UserRegistration() {
    *this = ::std::move(from);
  }

  inline UserRegistration& operator=(UserRegistration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRegistration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRegistration* internal_default_instance() {
    return reinterpret_cast<const UserRegistration*>(
               &_UserRegistration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(UserRegistration* other);
  friend void swap(UserRegistration& a, UserRegistration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRegistration* New() const final {
    return CreateMaybeMessage<UserRegistration>(NULL);
  }

  UserRegistration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRegistration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRegistration& from);
  void MergeFrom(const UserRegistration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRegistration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string ip = 2;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:chat.UserRegistration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.UserInfo) */ {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(UserInfo* other);
  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserInfo* New() const final {
    return CreateMaybeMessage<UserInfo>(NULL);
  }

  UserInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // string ip = 3;
  void clear_ip();
  static const int kIpFieldNumber = 3;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:chat.UserInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.UserRequest) */ {
 public:
  UserRequest();
  virtual ~UserRequest();

  UserRequest(const UserRequest& from);

  inline UserRequest& operator=(const UserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRequest(UserRequest&& from) noexcept
    : UserRequest() {
    *this = ::std::move(from);
  }

  inline UserRequest& operator=(UserRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRequest* internal_default_instance() {
    return reinterpret_cast<const UserRequest*>(
               &_UserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(UserRequest* other);
  friend void swap(UserRequest& a, UserRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRequest* New() const final {
    return CreateMaybeMessage<UserRequest>(NULL);
  }

  UserRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRequest& from);
  void MergeFrom(const UserRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user = 1;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:chat.UserRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConnectedUsersResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ConnectedUsersResponse) */ {
 public:
  ConnectedUsersResponse();
  virtual ~ConnectedUsersResponse();

  ConnectedUsersResponse(const ConnectedUsersResponse& from);

  inline ConnectedUsersResponse& operator=(const ConnectedUsersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectedUsersResponse(ConnectedUsersResponse&& from) noexcept
    : ConnectedUsersResponse() {
    *this = ::std::move(from);
  }

  inline ConnectedUsersResponse& operator=(ConnectedUsersResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectedUsersResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectedUsersResponse* internal_default_instance() {
    return reinterpret_cast<const ConnectedUsersResponse*>(
               &_ConnectedUsersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ConnectedUsersResponse* other);
  friend void swap(ConnectedUsersResponse& a, ConnectedUsersResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectedUsersResponse* New() const final {
    return CreateMaybeMessage<ConnectedUsersResponse>(NULL);
  }

  ConnectedUsersResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectedUsersResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectedUsersResponse& from);
  void MergeFrom(const ConnectedUsersResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectedUsersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .chat.UserInfo connectedUsers = 1;
  int connectedusers_size() const;
  void clear_connectedusers();
  static const int kConnectedUsersFieldNumber = 1;
  ::chat::UserInfo* mutable_connectedusers(int index);
  ::google::protobuf::RepeatedPtrField< ::chat::UserInfo >*
      mutable_connectedusers();
  const ::chat::UserInfo& connectedusers(int index) const;
  ::chat::UserInfo* add_connectedusers();
  const ::google::protobuf::RepeatedPtrField< ::chat::UserInfo >&
      connectedusers() const;

  // @@protoc_insertion_point(class_scope:chat.ConnectedUsersResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::chat::UserInfo > connectedusers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChangeStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ChangeStatus) */ {
 public:
  ChangeStatus();
  virtual ~ChangeStatus();

  ChangeStatus(const ChangeStatus& from);

  inline ChangeStatus& operator=(const ChangeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeStatus(ChangeStatus&& from) noexcept
    : ChangeStatus() {
    *this = ::std::move(from);
  }

  inline ChangeStatus& operator=(ChangeStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeStatus* internal_default_instance() {
    return reinterpret_cast<const ChangeStatus*>(
               &_ChangeStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ChangeStatus* other);
  friend void swap(ChangeStatus& a, ChangeStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeStatus* New() const final {
    return CreateMaybeMessage<ChangeStatus>(NULL);
  }

  ChangeStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangeStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangeStatus& from);
  void MergeFrom(const ChangeStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:chat.ChangeStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageCommunication : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.MessageCommunication) */ {
 public:
  MessageCommunication();
  virtual ~MessageCommunication();

  MessageCommunication(const MessageCommunication& from);

  inline MessageCommunication& operator=(const MessageCommunication& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageCommunication(MessageCommunication&& from) noexcept
    : MessageCommunication() {
    *this = ::std::move(from);
  }

  inline MessageCommunication& operator=(MessageCommunication&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageCommunication& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageCommunication* internal_default_instance() {
    return reinterpret_cast<const MessageCommunication*>(
               &_MessageCommunication_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(MessageCommunication* other);
  friend void swap(MessageCommunication& a, MessageCommunication& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageCommunication* New() const final {
    return CreateMaybeMessage<MessageCommunication>(NULL);
  }

  MessageCommunication* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageCommunication>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageCommunication& from);
  void MergeFrom(const MessageCommunication& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageCommunication* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // string recipient = 2;
  void clear_recipient();
  static const int kRecipientFieldNumber = 2;
  const ::std::string& recipient() const;
  void set_recipient(const ::std::string& value);
  #if LANG_CXX11
  void set_recipient(::std::string&& value);
  #endif
  void set_recipient(const char* value);
  void set_recipient(const char* value, size_t size);
  ::std::string* mutable_recipient();
  ::std::string* release_recipient();
  void set_allocated_recipient(::std::string* recipient);

  // string sender = 3;
  void clear_sender();
  static const int kSenderFieldNumber = 3;
  const ::std::string& sender() const;
  void set_sender(const ::std::string& value);
  #if LANG_CXX11
  void set_sender(::std::string&& value);
  #endif
  void set_sender(const char* value);
  void set_sender(const char* value, size_t size);
  ::std::string* mutable_sender();
  ::std::string* release_sender();
  void set_allocated_sender(::std::string* sender);

  // @@protoc_insertion_point(class_scope:chat.MessageCommunication)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr recipient_;
  ::google::protobuf::internal::ArenaStringPtr sender_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientPetition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ClientPetition) */ {
 public:
  ClientPetition();
  virtual ~ClientPetition();

  ClientPetition(const ClientPetition& from);

  inline ClientPetition& operator=(const ClientPetition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientPetition(ClientPetition&& from) noexcept
    : ClientPetition() {
    *this = ::std::move(from);
  }

  inline ClientPetition& operator=(ClientPetition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientPetition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientPetition* internal_default_instance() {
    return reinterpret_cast<const ClientPetition*>(
               &_ClientPetition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ClientPetition* other);
  friend void swap(ClientPetition& a, ClientPetition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientPetition* New() const final {
    return CreateMaybeMessage<ClientPetition>(NULL);
  }

  ClientPetition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientPetition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientPetition& from);
  void MergeFrom(const ClientPetition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientPetition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chat.UserRegistration registration = 2;
  bool has_registration() const;
  void clear_registration();
  static const int kRegistrationFieldNumber = 2;
  private:
  const ::chat::UserRegistration& _internal_registration() const;
  public:
  const ::chat::UserRegistration& registration() const;
  ::chat::UserRegistration* release_registration();
  ::chat::UserRegistration* mutable_registration();
  void set_allocated_registration(::chat::UserRegistration* registration);

  // .chat.UserRequest users = 3;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 3;
  private:
  const ::chat::UserRequest& _internal_users() const;
  public:
  const ::chat::UserRequest& users() const;
  ::chat::UserRequest* release_users();
  ::chat::UserRequest* mutable_users();
  void set_allocated_users(::chat::UserRequest* users);

  // .chat.ChangeStatus change = 4;
  bool has_change() const;
  void clear_change();
  static const int kChangeFieldNumber = 4;
  private:
  const ::chat::ChangeStatus& _internal_change() const;
  public:
  const ::chat::ChangeStatus& change() const;
  ::chat::ChangeStatus* release_change();
  ::chat::ChangeStatus* mutable_change();
  void set_allocated_change(::chat::ChangeStatus* change);

  // .chat.MessageCommunication messageCommunication = 5;
  bool has_messagecommunication() const;
  void clear_messagecommunication();
  static const int kMessageCommunicationFieldNumber = 5;
  private:
  const ::chat::MessageCommunication& _internal_messagecommunication() const;
  public:
  const ::chat::MessageCommunication& messagecommunication() const;
  ::chat::MessageCommunication* release_messagecommunication();
  ::chat::MessageCommunication* mutable_messagecommunication();
  void set_allocated_messagecommunication(::chat::MessageCommunication* messagecommunication);

  // int32 option = 1;
  void clear_option();
  static const int kOptionFieldNumber = 1;
  ::google::protobuf::int32 option() const;
  void set_option(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.ClientPetition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chat::UserRegistration* registration_;
  ::chat::UserRequest* users_;
  ::chat::ChangeStatus* change_;
  ::chat::MessageCommunication* messagecommunication_;
  ::google::protobuf::int32 option_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ServerResponse) */ {
 public:
  ServerResponse();
  virtual ~ServerResponse();

  ServerResponse(const ServerResponse& from);

  inline ServerResponse& operator=(const ServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerResponse(ServerResponse&& from) noexcept
    : ServerResponse() {
    *this = ::std::move(from);
  }

  inline ServerResponse& operator=(ServerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerResponse* internal_default_instance() {
    return reinterpret_cast<const ServerResponse*>(
               &_ServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ServerResponse* other);
  friend void swap(ServerResponse& a, ServerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerResponse* New() const final {
    return CreateMaybeMessage<ServerResponse>(NULL);
  }

  ServerResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerResponse& from);
  void MergeFrom(const ServerResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string serverMessage = 3;
  void clear_servermessage();
  static const int kServerMessageFieldNumber = 3;
  const ::std::string& servermessage() const;
  void set_servermessage(const ::std::string& value);
  #if LANG_CXX11
  void set_servermessage(::std::string&& value);
  #endif
  void set_servermessage(const char* value);
  void set_servermessage(const char* value, size_t size);
  ::std::string* mutable_servermessage();
  ::std::string* release_servermessage();
  void set_allocated_servermessage(::std::string* servermessage);

  // .chat.ConnectedUsersResponse connectedUsers = 4;
  bool has_connectedusers() const;
  void clear_connectedusers();
  static const int kConnectedUsersFieldNumber = 4;
  private:
  const ::chat::ConnectedUsersResponse& _internal_connectedusers() const;
  public:
  const ::chat::ConnectedUsersResponse& connectedusers() const;
  ::chat::ConnectedUsersResponse* release_connectedusers();
  ::chat::ConnectedUsersResponse* mutable_connectedusers();
  void set_allocated_connectedusers(::chat::ConnectedUsersResponse* connectedusers);

  // .chat.MessageCommunication messageCommunication = 5;
  bool has_messagecommunication() const;
  void clear_messagecommunication();
  static const int kMessageCommunicationFieldNumber = 5;
  private:
  const ::chat::MessageCommunication& _internal_messagecommunication() const;
  public:
  const ::chat::MessageCommunication& messagecommunication() const;
  ::chat::MessageCommunication* release_messagecommunication();
  ::chat::MessageCommunication* mutable_messagecommunication();
  void set_allocated_messagecommunication(::chat::MessageCommunication* messagecommunication);

  // .chat.UserInfo userInfoResponse = 6;
  bool has_userinforesponse() const;
  void clear_userinforesponse();
  static const int kUserInfoResponseFieldNumber = 6;
  private:
  const ::chat::UserInfo& _internal_userinforesponse() const;
  public:
  const ::chat::UserInfo& userinforesponse() const;
  ::chat::UserInfo* release_userinforesponse();
  ::chat::UserInfo* mutable_userinforesponse();
  void set_allocated_userinforesponse(::chat::UserInfo* userinforesponse);

  // .chat.ChangeStatus change = 7;
  bool has_change() const;
  void clear_change();
  static const int kChangeFieldNumber = 7;
  private:
  const ::chat::ChangeStatus& _internal_change() const;
  public:
  const ::chat::ChangeStatus& change() const;
  ::chat::ChangeStatus* release_change();
  ::chat::ChangeStatus* mutable_change();
  void set_allocated_change(::chat::ChangeStatus* change);

  // int32 option = 1;
  void clear_option();
  static const int kOptionFieldNumber = 1;
  ::google::protobuf::int32 option() const;
  void set_option(::google::protobuf::int32 value);

  // int32 code = 2;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.ServerResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr servermessage_;
  ::chat::ConnectedUsersResponse* connectedusers_;
  ::chat::MessageCommunication* messagecommunication_;
  ::chat::UserInfo* userinforesponse_;
  ::chat::ChangeStatus* change_;
  ::google::protobuf::int32 option_;
  ::google::protobuf::int32 code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chat_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserRegistration

// string username = 1;
inline void UserRegistration::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserRegistration::username() const {
  // @@protoc_insertion_point(field_get:chat.UserRegistration.username)
  return username_.GetNoArena();
}
inline void UserRegistration::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.UserRegistration.username)
}
#if LANG_CXX11
inline void UserRegistration::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.UserRegistration.username)
}
#endif
inline void UserRegistration::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.UserRegistration.username)
}
inline void UserRegistration::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.UserRegistration.username)
}
inline ::std::string* UserRegistration::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chat.UserRegistration.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRegistration::release_username() {
  // @@protoc_insertion_point(field_release:chat.UserRegistration.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRegistration::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.UserRegistration.username)
}

// string ip = 2;
inline void UserRegistration::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserRegistration::ip() const {
  // @@protoc_insertion_point(field_get:chat.UserRegistration.ip)
  return ip_.GetNoArena();
}
inline void UserRegistration::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.UserRegistration.ip)
}
#if LANG_CXX11
inline void UserRegistration::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.UserRegistration.ip)
}
#endif
inline void UserRegistration::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.UserRegistration.ip)
}
inline void UserRegistration::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.UserRegistration.ip)
}
inline ::std::string* UserRegistration::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:chat.UserRegistration.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRegistration::release_ip() {
  // @@protoc_insertion_point(field_release:chat.UserRegistration.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRegistration::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:chat.UserRegistration.ip)
}

// -------------------------------------------------------------------

// UserInfo

// string username = 1;
inline void UserInfo::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserInfo::username() const {
  // @@protoc_insertion_point(field_get:chat.UserInfo.username)
  return username_.GetNoArena();
}
inline void UserInfo::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.UserInfo.username)
}
#if LANG_CXX11
inline void UserInfo::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.UserInfo.username)
}
#endif
inline void UserInfo::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.UserInfo.username)
}
inline void UserInfo::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.UserInfo.username)
}
inline ::std::string* UserInfo::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chat.UserInfo.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_username() {
  // @@protoc_insertion_point(field_release:chat.UserInfo.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.UserInfo.username)
}

// string status = 2;
inline void UserInfo::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserInfo::status() const {
  // @@protoc_insertion_point(field_get:chat.UserInfo.status)
  return status_.GetNoArena();
}
inline void UserInfo::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.UserInfo.status)
}
#if LANG_CXX11
inline void UserInfo::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.UserInfo.status)
}
#endif
inline void UserInfo::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.UserInfo.status)
}
inline void UserInfo::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.UserInfo.status)
}
inline ::std::string* UserInfo::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:chat.UserInfo.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_status() {
  // @@protoc_insertion_point(field_release:chat.UserInfo.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:chat.UserInfo.status)
}

// string ip = 3;
inline void UserInfo::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserInfo::ip() const {
  // @@protoc_insertion_point(field_get:chat.UserInfo.ip)
  return ip_.GetNoArena();
}
inline void UserInfo::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.UserInfo.ip)
}
#if LANG_CXX11
inline void UserInfo::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.UserInfo.ip)
}
#endif
inline void UserInfo::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.UserInfo.ip)
}
inline void UserInfo::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.UserInfo.ip)
}
inline ::std::string* UserInfo::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:chat.UserInfo.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_ip() {
  // @@protoc_insertion_point(field_release:chat.UserInfo.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:chat.UserInfo.ip)
}

// -------------------------------------------------------------------

// UserRequest

// string user = 1;
inline void UserRequest::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserRequest::user() const {
  // @@protoc_insertion_point(field_get:chat.UserRequest.user)
  return user_.GetNoArena();
}
inline void UserRequest::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.UserRequest.user)
}
#if LANG_CXX11
inline void UserRequest::set_user(::std::string&& value) {
  
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.UserRequest.user)
}
#endif
inline void UserRequest::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.UserRequest.user)
}
inline void UserRequest::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.UserRequest.user)
}
inline ::std::string* UserRequest::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:chat.UserRequest.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRequest::release_user() {
  // @@protoc_insertion_point(field_release:chat.UserRequest.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRequest::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:chat.UserRequest.user)
}

// -------------------------------------------------------------------

// ConnectedUsersResponse

// repeated .chat.UserInfo connectedUsers = 1;
inline int ConnectedUsersResponse::connectedusers_size() const {
  return connectedusers_.size();
}
inline void ConnectedUsersResponse::clear_connectedusers() {
  connectedusers_.Clear();
}
inline ::chat::UserInfo* ConnectedUsersResponse::mutable_connectedusers(int index) {
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUsersResponse.connectedUsers)
  return connectedusers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chat::UserInfo >*
ConnectedUsersResponse::mutable_connectedusers() {
  // @@protoc_insertion_point(field_mutable_list:chat.ConnectedUsersResponse.connectedUsers)
  return &connectedusers_;
}
inline const ::chat::UserInfo& ConnectedUsersResponse::connectedusers(int index) const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUsersResponse.connectedUsers)
  return connectedusers_.Get(index);
}
inline ::chat::UserInfo* ConnectedUsersResponse::add_connectedusers() {
  // @@protoc_insertion_point(field_add:chat.ConnectedUsersResponse.connectedUsers)
  return connectedusers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chat::UserInfo >&
ConnectedUsersResponse::connectedusers() const {
  // @@protoc_insertion_point(field_list:chat.ConnectedUsersResponse.connectedUsers)
  return connectedusers_;
}

// -------------------------------------------------------------------

// ChangeStatus

// string username = 1;
inline void ChangeStatus::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangeStatus::username() const {
  // @@protoc_insertion_point(field_get:chat.ChangeStatus.username)
  return username_.GetNoArena();
}
inline void ChangeStatus::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ChangeStatus.username)
}
#if LANG_CXX11
inline void ChangeStatus::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.ChangeStatus.username)
}
#endif
inline void ChangeStatus::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ChangeStatus.username)
}
inline void ChangeStatus::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ChangeStatus.username)
}
inline ::std::string* ChangeStatus::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:chat.ChangeStatus.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeStatus::release_username() {
  // @@protoc_insertion_point(field_release:chat.ChangeStatus.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeStatus::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.ChangeStatus.username)
}

// string status = 2;
inline void ChangeStatus::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangeStatus::status() const {
  // @@protoc_insertion_point(field_get:chat.ChangeStatus.status)
  return status_.GetNoArena();
}
inline void ChangeStatus::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ChangeStatus.status)
}
#if LANG_CXX11
inline void ChangeStatus::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.ChangeStatus.status)
}
#endif
inline void ChangeStatus::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ChangeStatus.status)
}
inline void ChangeStatus::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ChangeStatus.status)
}
inline ::std::string* ChangeStatus::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:chat.ChangeStatus.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeStatus::release_status() {
  // @@protoc_insertion_point(field_release:chat.ChangeStatus.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeStatus::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:chat.ChangeStatus.status)
}

// -------------------------------------------------------------------

// MessageCommunication

// string message = 1;
inline void MessageCommunication::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessageCommunication::message() const {
  // @@protoc_insertion_point(field_get:chat.MessageCommunication.message)
  return message_.GetNoArena();
}
inline void MessageCommunication::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.MessageCommunication.message)
}
#if LANG_CXX11
inline void MessageCommunication::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.MessageCommunication.message)
}
#endif
inline void MessageCommunication::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.MessageCommunication.message)
}
inline void MessageCommunication::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.MessageCommunication.message)
}
inline ::std::string* MessageCommunication::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:chat.MessageCommunication.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageCommunication::release_message() {
  // @@protoc_insertion_point(field_release:chat.MessageCommunication.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageCommunication::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:chat.MessageCommunication.message)
}

// string recipient = 2;
inline void MessageCommunication::clear_recipient() {
  recipient_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessageCommunication::recipient() const {
  // @@protoc_insertion_point(field_get:chat.MessageCommunication.recipient)
  return recipient_.GetNoArena();
}
inline void MessageCommunication::set_recipient(const ::std::string& value) {
  
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.MessageCommunication.recipient)
}
#if LANG_CXX11
inline void MessageCommunication::set_recipient(::std::string&& value) {
  
  recipient_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.MessageCommunication.recipient)
}
#endif
inline void MessageCommunication::set_recipient(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.MessageCommunication.recipient)
}
inline void MessageCommunication::set_recipient(const char* value, size_t size) {
  
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.MessageCommunication.recipient)
}
inline ::std::string* MessageCommunication::mutable_recipient() {
  
  // @@protoc_insertion_point(field_mutable:chat.MessageCommunication.recipient)
  return recipient_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageCommunication::release_recipient() {
  // @@protoc_insertion_point(field_release:chat.MessageCommunication.recipient)
  
  return recipient_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageCommunication::set_allocated_recipient(::std::string* recipient) {
  if (recipient != NULL) {
    
  } else {
    
  }
  recipient_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recipient);
  // @@protoc_insertion_point(field_set_allocated:chat.MessageCommunication.recipient)
}

// string sender = 3;
inline void MessageCommunication::clear_sender() {
  sender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessageCommunication::sender() const {
  // @@protoc_insertion_point(field_get:chat.MessageCommunication.sender)
  return sender_.GetNoArena();
}
inline void MessageCommunication::set_sender(const ::std::string& value) {
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.MessageCommunication.sender)
}
#if LANG_CXX11
inline void MessageCommunication::set_sender(::std::string&& value) {
  
  sender_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.MessageCommunication.sender)
}
#endif
inline void MessageCommunication::set_sender(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.MessageCommunication.sender)
}
inline void MessageCommunication::set_sender(const char* value, size_t size) {
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.MessageCommunication.sender)
}
inline ::std::string* MessageCommunication::mutable_sender() {
  
  // @@protoc_insertion_point(field_mutable:chat.MessageCommunication.sender)
  return sender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageCommunication::release_sender() {
  // @@protoc_insertion_point(field_release:chat.MessageCommunication.sender)
  
  return sender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageCommunication::set_allocated_sender(::std::string* sender) {
  if (sender != NULL) {
    
  } else {
    
  }
  sender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender);
  // @@protoc_insertion_point(field_set_allocated:chat.MessageCommunication.sender)
}

// -------------------------------------------------------------------

// ClientPetition

// int32 option = 1;
inline void ClientPetition::clear_option() {
  option_ = 0;
}
inline ::google::protobuf::int32 ClientPetition::option() const {
  // @@protoc_insertion_point(field_get:chat.ClientPetition.option)
  return option_;
}
inline void ClientPetition::set_option(::google::protobuf::int32 value) {
  
  option_ = value;
  // @@protoc_insertion_point(field_set:chat.ClientPetition.option)
}

// .chat.UserRegistration registration = 2;
inline bool ClientPetition::has_registration() const {
  return this != internal_default_instance() && registration_ != NULL;
}
inline void ClientPetition::clear_registration() {
  if (GetArenaNoVirtual() == NULL && registration_ != NULL) {
    delete registration_;
  }
  registration_ = NULL;
}
inline const ::chat::UserRegistration& ClientPetition::_internal_registration() const {
  return *registration_;
}
inline const ::chat::UserRegistration& ClientPetition::registration() const {
  const ::chat::UserRegistration* p = registration_;
  // @@protoc_insertion_point(field_get:chat.ClientPetition.registration)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::UserRegistration*>(
      &::chat::_UserRegistration_default_instance_);
}
inline ::chat::UserRegistration* ClientPetition::release_registration() {
  // @@protoc_insertion_point(field_release:chat.ClientPetition.registration)
  
  ::chat::UserRegistration* temp = registration_;
  registration_ = NULL;
  return temp;
}
inline ::chat::UserRegistration* ClientPetition::mutable_registration() {
  
  if (registration_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::UserRegistration>(GetArenaNoVirtual());
    registration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientPetition.registration)
  return registration_;
}
inline void ClientPetition::set_allocated_registration(::chat::UserRegistration* registration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete registration_;
  }
  if (registration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      registration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, registration, submessage_arena);
    }
    
  } else {
    
  }
  registration_ = registration;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientPetition.registration)
}

// .chat.UserRequest users = 3;
inline bool ClientPetition::has_users() const {
  return this != internal_default_instance() && users_ != NULL;
}
inline void ClientPetition::clear_users() {
  if (GetArenaNoVirtual() == NULL && users_ != NULL) {
    delete users_;
  }
  users_ = NULL;
}
inline const ::chat::UserRequest& ClientPetition::_internal_users() const {
  return *users_;
}
inline const ::chat::UserRequest& ClientPetition::users() const {
  const ::chat::UserRequest* p = users_;
  // @@protoc_insertion_point(field_get:chat.ClientPetition.users)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::UserRequest*>(
      &::chat::_UserRequest_default_instance_);
}
inline ::chat::UserRequest* ClientPetition::release_users() {
  // @@protoc_insertion_point(field_release:chat.ClientPetition.users)
  
  ::chat::UserRequest* temp = users_;
  users_ = NULL;
  return temp;
}
inline ::chat::UserRequest* ClientPetition::mutable_users() {
  
  if (users_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::UserRequest>(GetArenaNoVirtual());
    users_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientPetition.users)
  return users_;
}
inline void ClientPetition::set_allocated_users(::chat::UserRequest* users) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete users_;
  }
  if (users) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      users = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    
  } else {
    
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientPetition.users)
}

// .chat.ChangeStatus change = 4;
inline bool ClientPetition::has_change() const {
  return this != internal_default_instance() && change_ != NULL;
}
inline void ClientPetition::clear_change() {
  if (GetArenaNoVirtual() == NULL && change_ != NULL) {
    delete change_;
  }
  change_ = NULL;
}
inline const ::chat::ChangeStatus& ClientPetition::_internal_change() const {
  return *change_;
}
inline const ::chat::ChangeStatus& ClientPetition::change() const {
  const ::chat::ChangeStatus* p = change_;
  // @@protoc_insertion_point(field_get:chat.ClientPetition.change)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::ChangeStatus*>(
      &::chat::_ChangeStatus_default_instance_);
}
inline ::chat::ChangeStatus* ClientPetition::release_change() {
  // @@protoc_insertion_point(field_release:chat.ClientPetition.change)
  
  ::chat::ChangeStatus* temp = change_;
  change_ = NULL;
  return temp;
}
inline ::chat::ChangeStatus* ClientPetition::mutable_change() {
  
  if (change_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::ChangeStatus>(GetArenaNoVirtual());
    change_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientPetition.change)
  return change_;
}
inline void ClientPetition::set_allocated_change(::chat::ChangeStatus* change) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete change_;
  }
  if (change) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      change = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, change, submessage_arena);
    }
    
  } else {
    
  }
  change_ = change;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientPetition.change)
}

// .chat.MessageCommunication messageCommunication = 5;
inline bool ClientPetition::has_messagecommunication() const {
  return this != internal_default_instance() && messagecommunication_ != NULL;
}
inline void ClientPetition::clear_messagecommunication() {
  if (GetArenaNoVirtual() == NULL && messagecommunication_ != NULL) {
    delete messagecommunication_;
  }
  messagecommunication_ = NULL;
}
inline const ::chat::MessageCommunication& ClientPetition::_internal_messagecommunication() const {
  return *messagecommunication_;
}
inline const ::chat::MessageCommunication& ClientPetition::messagecommunication() const {
  const ::chat::MessageCommunication* p = messagecommunication_;
  // @@protoc_insertion_point(field_get:chat.ClientPetition.messageCommunication)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::MessageCommunication*>(
      &::chat::_MessageCommunication_default_instance_);
}
inline ::chat::MessageCommunication* ClientPetition::release_messagecommunication() {
  // @@protoc_insertion_point(field_release:chat.ClientPetition.messageCommunication)
  
  ::chat::MessageCommunication* temp = messagecommunication_;
  messagecommunication_ = NULL;
  return temp;
}
inline ::chat::MessageCommunication* ClientPetition::mutable_messagecommunication() {
  
  if (messagecommunication_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::MessageCommunication>(GetArenaNoVirtual());
    messagecommunication_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientPetition.messageCommunication)
  return messagecommunication_;
}
inline void ClientPetition::set_allocated_messagecommunication(::chat::MessageCommunication* messagecommunication) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete messagecommunication_;
  }
  if (messagecommunication) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      messagecommunication = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, messagecommunication, submessage_arena);
    }
    
  } else {
    
  }
  messagecommunication_ = messagecommunication;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientPetition.messageCommunication)
}

// -------------------------------------------------------------------

// ServerResponse

// int32 option = 1;
inline void ServerResponse::clear_option() {
  option_ = 0;
}
inline ::google::protobuf::int32 ServerResponse::option() const {
  // @@protoc_insertion_point(field_get:chat.ServerResponse.option)
  return option_;
}
inline void ServerResponse::set_option(::google::protobuf::int32 value) {
  
  option_ = value;
  // @@protoc_insertion_point(field_set:chat.ServerResponse.option)
}

// int32 code = 2;
inline void ServerResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 ServerResponse::code() const {
  // @@protoc_insertion_point(field_get:chat.ServerResponse.code)
  return code_;
}
inline void ServerResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:chat.ServerResponse.code)
}

// string serverMessage = 3;
inline void ServerResponse::clear_servermessage() {
  servermessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerResponse::servermessage() const {
  // @@protoc_insertion_point(field_get:chat.ServerResponse.serverMessage)
  return servermessage_.GetNoArena();
}
inline void ServerResponse::set_servermessage(const ::std::string& value) {
  
  servermessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ServerResponse.serverMessage)
}
#if LANG_CXX11
inline void ServerResponse::set_servermessage(::std::string&& value) {
  
  servermessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chat.ServerResponse.serverMessage)
}
#endif
inline void ServerResponse::set_servermessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  servermessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ServerResponse.serverMessage)
}
inline void ServerResponse::set_servermessage(const char* value, size_t size) {
  
  servermessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ServerResponse.serverMessage)
}
inline ::std::string* ServerResponse::mutable_servermessage() {
  
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.serverMessage)
  return servermessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerResponse::release_servermessage() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.serverMessage)
  
  return servermessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerResponse::set_allocated_servermessage(::std::string* servermessage) {
  if (servermessage != NULL) {
    
  } else {
    
  }
  servermessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), servermessage);
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.serverMessage)
}

// .chat.ConnectedUsersResponse connectedUsers = 4;
inline bool ServerResponse::has_connectedusers() const {
  return this != internal_default_instance() && connectedusers_ != NULL;
}
inline void ServerResponse::clear_connectedusers() {
  if (GetArenaNoVirtual() == NULL && connectedusers_ != NULL) {
    delete connectedusers_;
  }
  connectedusers_ = NULL;
}
inline const ::chat::ConnectedUsersResponse& ServerResponse::_internal_connectedusers() const {
  return *connectedusers_;
}
inline const ::chat::ConnectedUsersResponse& ServerResponse::connectedusers() const {
  const ::chat::ConnectedUsersResponse* p = connectedusers_;
  // @@protoc_insertion_point(field_get:chat.ServerResponse.connectedUsers)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::ConnectedUsersResponse*>(
      &::chat::_ConnectedUsersResponse_default_instance_);
}
inline ::chat::ConnectedUsersResponse* ServerResponse::release_connectedusers() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.connectedUsers)
  
  ::chat::ConnectedUsersResponse* temp = connectedusers_;
  connectedusers_ = NULL;
  return temp;
}
inline ::chat::ConnectedUsersResponse* ServerResponse::mutable_connectedusers() {
  
  if (connectedusers_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::ConnectedUsersResponse>(GetArenaNoVirtual());
    connectedusers_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.connectedUsers)
  return connectedusers_;
}
inline void ServerResponse::set_allocated_connectedusers(::chat::ConnectedUsersResponse* connectedusers) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete connectedusers_;
  }
  if (connectedusers) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connectedusers = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connectedusers, submessage_arena);
    }
    
  } else {
    
  }
  connectedusers_ = connectedusers;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.connectedUsers)
}

// .chat.MessageCommunication messageCommunication = 5;
inline bool ServerResponse::has_messagecommunication() const {
  return this != internal_default_instance() && messagecommunication_ != NULL;
}
inline void ServerResponse::clear_messagecommunication() {
  if (GetArenaNoVirtual() == NULL && messagecommunication_ != NULL) {
    delete messagecommunication_;
  }
  messagecommunication_ = NULL;
}
inline const ::chat::MessageCommunication& ServerResponse::_internal_messagecommunication() const {
  return *messagecommunication_;
}
inline const ::chat::MessageCommunication& ServerResponse::messagecommunication() const {
  const ::chat::MessageCommunication* p = messagecommunication_;
  // @@protoc_insertion_point(field_get:chat.ServerResponse.messageCommunication)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::MessageCommunication*>(
      &::chat::_MessageCommunication_default_instance_);
}
inline ::chat::MessageCommunication* ServerResponse::release_messagecommunication() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.messageCommunication)
  
  ::chat::MessageCommunication* temp = messagecommunication_;
  messagecommunication_ = NULL;
  return temp;
}
inline ::chat::MessageCommunication* ServerResponse::mutable_messagecommunication() {
  
  if (messagecommunication_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::MessageCommunication>(GetArenaNoVirtual());
    messagecommunication_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.messageCommunication)
  return messagecommunication_;
}
inline void ServerResponse::set_allocated_messagecommunication(::chat::MessageCommunication* messagecommunication) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete messagecommunication_;
  }
  if (messagecommunication) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      messagecommunication = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, messagecommunication, submessage_arena);
    }
    
  } else {
    
  }
  messagecommunication_ = messagecommunication;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.messageCommunication)
}

// .chat.UserInfo userInfoResponse = 6;
inline bool ServerResponse::has_userinforesponse() const {
  return this != internal_default_instance() && userinforesponse_ != NULL;
}
inline void ServerResponse::clear_userinforesponse() {
  if (GetArenaNoVirtual() == NULL && userinforesponse_ != NULL) {
    delete userinforesponse_;
  }
  userinforesponse_ = NULL;
}
inline const ::chat::UserInfo& ServerResponse::_internal_userinforesponse() const {
  return *userinforesponse_;
}
inline const ::chat::UserInfo& ServerResponse::userinforesponse() const {
  const ::chat::UserInfo* p = userinforesponse_;
  // @@protoc_insertion_point(field_get:chat.ServerResponse.userInfoResponse)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::UserInfo*>(
      &::chat::_UserInfo_default_instance_);
}
inline ::chat::UserInfo* ServerResponse::release_userinforesponse() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.userInfoResponse)
  
  ::chat::UserInfo* temp = userinforesponse_;
  userinforesponse_ = NULL;
  return temp;
}
inline ::chat::UserInfo* ServerResponse::mutable_userinforesponse() {
  
  if (userinforesponse_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::UserInfo>(GetArenaNoVirtual());
    userinforesponse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.userInfoResponse)
  return userinforesponse_;
}
inline void ServerResponse::set_allocated_userinforesponse(::chat::UserInfo* userinforesponse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete userinforesponse_;
  }
  if (userinforesponse) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      userinforesponse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, userinforesponse, submessage_arena);
    }
    
  } else {
    
  }
  userinforesponse_ = userinforesponse;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.userInfoResponse)
}

// .chat.ChangeStatus change = 7;
inline bool ServerResponse::has_change() const {
  return this != internal_default_instance() && change_ != NULL;
}
inline void ServerResponse::clear_change() {
  if (GetArenaNoVirtual() == NULL && change_ != NULL) {
    delete change_;
  }
  change_ = NULL;
}
inline const ::chat::ChangeStatus& ServerResponse::_internal_change() const {
  return *change_;
}
inline const ::chat::ChangeStatus& ServerResponse::change() const {
  const ::chat::ChangeStatus* p = change_;
  // @@protoc_insertion_point(field_get:chat.ServerResponse.change)
  return p != NULL ? *p : *reinterpret_cast<const ::chat::ChangeStatus*>(
      &::chat::_ChangeStatus_default_instance_);
}
inline ::chat::ChangeStatus* ServerResponse::release_change() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.change)
  
  ::chat::ChangeStatus* temp = change_;
  change_ = NULL;
  return temp;
}
inline ::chat::ChangeStatus* ServerResponse::mutable_change() {
  
  if (change_ == NULL) {
    auto* p = CreateMaybeMessage<::chat::ChangeStatus>(GetArenaNoVirtual());
    change_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.change)
  return change_;
}
inline void ServerResponse::set_allocated_change(::chat::ChangeStatus* change) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete change_;
  }
  if (change) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      change = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, change, submessage_arena);
    }
    
  } else {
    
  }
  change_ = change;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.change)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chat

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_chat_2eproto
